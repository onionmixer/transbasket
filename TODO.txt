==기본내용==
* Python POC는 FastAPI 기반 단일 HTTP POST 엔드포인트로 요청을 수신하고 응답이 준비될 때까지 연결을 유지하며, 필요 시 StreamingResponse로 점진 전송을 선택 가능하게 설계한다.

* 요청 JSON 스키마 초안:
{
  "timestamp": "RFC3339 string",
  "uuid": "UUID v4 string",
  "from": "language code",
  "to": "language code",
  "text": "string"
}

* 응답 JSON 스키마 초안:
{
  "timestamp": "RFC3339 string",
  "uuid": "UUID v4 string",
  "from": "language code",
  "to": "language code",
  "text": "string",
  "translated_text": "string"
}
* timestamp는 RFC 3339 규격, uuid는 RFC 4122 v4로 밸리데이션하며, 응답에는 원문 필드와 함께 번역 결과 필드를 포함한다.
* 향후 structured outputs가 필요하면 Responses API의 JSON 지향 출력 제어를 조합해 파서 안전성을 높일 수 있도록 확장 포인트를 문서화한다.
* 요청 수신은 FastAPI의 비동기 핸들러로 I/O 바운드 처리를 효율화하고, 내부 처리(대기 포함)는 스레드 풀로 위임해 “스레드 구조 유지” 요건을 충족한다.
* 전략은 “async + thread pool 하이브리드”: 네트워크 대기는 async로, 블로킹 호출이나 외부 SDK 호환성 이슈는 ThreadPoolExecutor/전용 워커 스레드로 처리해 고부하에서도 응답성을 확보한다.

* 응답 생성 시 원문과 동일한 uuid/timestamp를 유지하고 translated_text를 추가해 클라이언트의 대응 매칭을 단순화한다.
* OpenAI 호출 타임아웃, 4xx/5xx 매핑, 재시도 정책(멱등 기준은 uuid 단위)을 정의하고, 클라이언트에는 원인 구분 가능한 오류 코드를 포함한 JSON 바디를 반환한다.
* 서버 내부 큐 포화 시 503과 함께 재시도 지침을 명시하고, 장기 실행 시에는 백오프 기반 재시도를 적용한다.
* 각 요청·응답에 uuid를 상관키로 사용하고, 수명주기 로그에 수신→큐잉→OpenAI 호출→응답 전송까지의 단계별 소요 시간을 기록한다.
* 타임스탬프는 RFC 3339로 표준화해 로그 파이프라인 및 외부 모니터링과의 정렬을 보장한다.

* 기본은 요청 완료 시까지 HTTP 연결 유지 후 종료하며, 필요 시 StreamingResponse를 사용해 진행 상황 또는 부분 결과를 전송하는 대안을 제공한다.
* 장기 연결 대비를 위해 서버 타임아웃과 리버스 프록시(있는 경우) 타임아웃을 일치시키고, 청크 전송 시 적절한 청크 크기를 선택한다.

==개발절차==

step 1: API 계약·스키마·에러 모델 명세서 작성 및 샘플 페이로드 확정(RFC 3339, UUID v4 포함).
step 2: conf 스키마 설계 및 configparser 기반 로더·밸리데이터 구현.
step 3: FastAPI 엔드포인트, 큐·워커 스레드, OpenAI 호출 모듈, 타임아웃·재시도·로깅 기초 구현.
step 4: 연결 유지·스트리밍 대응, 오류 매핑, 관측 로그 확장 및 임계치 튜닝.
step 5: systemd 유닛 작성·배포·운영 가이드 작성 및 재시작 정책 검증.
step 6: 부하·장애 주입 테스트로 안정화 후 POC 기능 동결 및 코드 정리.

==C 포팅 계획==
* 공용 계약은 그대로 유지하고(RFC 3339, UUID v4), 모듈 경계를 동일하게 설정해 컴포넌트 대체만으로 이행 가능하도록 한다.
* HTTP 서버·HTTP 클라이언트·JSON 파서·워커 스레드 계층을 C로 치환하고, 동일한 systemd 배포·운영 방식을 적용한다.
* 기능 동등성·성능 회귀를 검증하는 승인 테스트를 Python POC와 동일한 계약으로 수행한다.
